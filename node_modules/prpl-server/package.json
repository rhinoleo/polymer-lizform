{
  "_args": [
    [
      {
        "raw": "prpl-server",
        "scope": null,
        "escapedName": "prpl-server",
        "name": "prpl-server",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "F:\\Webdesign\\Polymer\\polymer-lizform"
    ]
  ],
  "_from": "prpl-server@latest",
  "_id": "prpl-server@1.0.0",
  "_inCache": true,
  "_location": "/prpl-server",
  "_nodeVersion": "9.0.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/prpl-server-1.0.0.tgz_1509511652483_0.7262931673321873"
  },
  "_npmUser": {
    "name": "polymer",
    "email": "admin@polymer-project.org"
  },
  "_npmVersion": "5.5.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "prpl-server",
    "scope": null,
    "escapedName": "prpl-server",
    "name": "prpl-server",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/prpl-server/-/prpl-server-1.0.0.tgz",
  "_shasum": "316555a503bed68f370ddd23c38e1de608fbd985",
  "_shrinkwrap": null,
  "_spec": "prpl-server",
  "_where": "F:\\Webdesign\\Polymer\\polymer-lizform",
  "author": {
    "name": "The Polymer Project Authors"
  },
  "bin": {
    "prpl-server": "bin/prpl-server"
  },
  "bugs": {
    "url": "https://github.com/Polymer/prpl-server-node/issues"
  },
  "dependencies": {
    "@types/compression": "0.0.34",
    "@types/express": "^4.0.35",
    "@types/http-errors": "^1.6.1",
    "@types/node": "^8.0.47",
    "@types/send": "^0.14.2",
    "@types/statuses": "^1.3.0",
    "@types/valid-url": "^1.0.2",
    "ansi-escape-sequences": "^4.0.0",
    "browser-capabilities": "^0.2.1",
    "command-line-args": "^4.0.4",
    "command-line-usage": "^4.0.0",
    "compression": "^1.6.2",
    "express": "^4.15.2",
    "http-errors": "^1.6.2",
    "rendertron-middleware": "^0.1.1",
    "send": "^0.16.1",
    "statuses": "^1.4.0",
    "valid-url": "^1.0.9"
  },
  "description": "A Node implementation of the PRPL pattern for serving Progressive Web Apps",
  "devDependencies": {
    "@types/chai": "^4.0.2",
    "@types/mocha": "^2.2.41",
    "chai": "^4.1.1",
    "clang-format": "^1.0.50",
    "mocha": "^4.0.1",
    "source-map-support": "^0.5.0",
    "typescript": "^2.6.1",
    "watchy": "^0.7.0"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-UI9dQCzgad27O7o1qY4g3A0lKa1uDtbwj4xGUnKt2X8L/AJ8OP7rSm9Iyks/ag8Cx3Q49HgNuP0Euujl3eQSOA==",
    "shasum": "316555a503bed68f370ddd23c38e1de608fbd985",
    "tarball": "https://registry.npmjs.org/prpl-server/-/prpl-server-1.0.0.tgz"
  },
  "engines": {
    "node": ">=6.0"
  },
  "gitHead": "c9766df0707936dbb3e1b1f141a634298fbade5a",
  "homepage": "https://github.com/Polymer/prpl-server-node#readme",
  "license": "BSD-3-Clause",
  "main": "lib/prpl.js",
  "maintainers": [
    {
      "name": "polymer",
      "email": "admin@polymer-project.org"
    }
  ],
  "name": "prpl-server",
  "optionalDependencies": {},
  "readme": "[![Travis Build Status](https://travis-ci.org/Polymer/prpl-server-node.svg?branch=master)](https://travis-ci.org/Polymer/prpl-server-node)\n[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/3bfbf7fgdifebv7o/branch/master?svg=true)](https://ci.appveyor.com/project/aomarks/prpl-server-node/branch/master)\n[![NPM version](http://img.shields.io/npm/v/prpl-server.svg)](https://www.npmjs.com/package/prpl-server)\n\n# prpl-server-node\n\nAn HTTP server for Node designed to serve [PRPL](https://developers.google.com/web/fundamentals/performance/prpl-pattern/) apps in production.\n\n## Usage\n\n### As a binary\n```sh\n$ npm install -g prpl-server\n$ prpl-server --root . --config polymer.json\n```\n\n### As a library\n\n```sh\n$ npm install --save prpl-server\n```\n\n```js\nprpl = require('prpl-server');\nexpress = require('express');\n\nconst app = express()\n\napp.get('/api/launch', (req, res, next) => res.send('boom'));\n\napp.get('/*', prpl.makeHandler('.', {\n  builds: [\n    {name: 'modern', browserCapabilities: ['es2015', 'push']},\n    {name: 'fallback'},\n  ],\n}));\n\napp.listen(8080);\n```\n\n## Differential Serving\n\nModern browsers offer great features that improve performance, but most applications need to support older browsers too. prpl-server can serve different versions of your application to different browsers by detecting browser capabilities using the user-agent header.\n\n### Builds\n\nprpl-server understands the notion of a *build*, a variant of your application optimized for a particular set of browser capabilities.\n\nBuilds are specified in a JSON configuration file. This format is compatible with [`polymer.json`](https://www.polymer-project.org/2.0/docs/tools/polymer-json), so if you are already using polymer-cli for your build pipeline, you can annotate your existing builds with browser capabilities, and copy the configuration to your server root. prpl-server will look for a file called `polymer.json` in the server root, or you can specify it directly with the `--config` flag.\n\n\nIn this example we define two builds, one for modern browsers that support ES2015 and HTTP/2 Push, and a fallback build for other browsers:\n\n```\n{\n  \"entrypoint: \"index.html\",\n  \"builds\": [\n    {\"name\": \"modern\", \"browserCapabilities\": [\"es2015\", \"push\"]},\n    {\"name\": \"fallback\"}\n  ]\n}\n```\n\n### Capabilities\n\nThe `browserCapabilities` field defines the browser features required for that build. prpl-server analyzes the request user-agent header and picks the best build for which all capabilities are met. If multiple builds are compatible, the one with more capabilities is preferred. If there is a tie, the build that comes earlier in the configuration file wins.\n\nYou should always include a fallback build with no capability requirements. If you don't, prpl-server will warn at startup, and will return a 500 error on entrypoint requests to browsers for which no build can be served.\n\nThe following keywords are supported. See also the [browser-capabilities](https://github.com/Polymer/browser-capabilities) library which prpl-server uses.\n\n| Keyword       | Description\n| :----         | :----\n| es2015        | [ECMAScript 2015 (aka ES6)](https://developers.google.com/web/shows/ttt/series-2/es2015)\n| push          | [HTTP/2 Server Push](https://developers.google.com/web/fundamentals/performance/http2/#server-push)\n| serviceworker | [Service Worker API](https://developers.google.com/web/fundamentals/getting-started/primers/service-workers)\n| modules       | [JavaScript Modules](https://www.chromestatus.com/feature/5365692190687232)\n\n\n## Entrypoint\n\nIn the [PRPL pattern](https://developers.google.com/web/fundamentals/performance/prpl-pattern/), the *entrypoint* is a small HTML file that acts as the application bootstrap.\n\nprpl-server will serve the entrypoint from the best compatible build from `/`, and from any path that does not have a file extension and is not an existing file.\n\nprpl-server expects that each build subdirectory contains its own entrypoint file. By default it is `index.html`, or you can specify another name with the `entrypoint` configuration file setting.\n\nNote that because the entrypoint is served from many URLs, and varies by user-agent, cache hits for the entrypoint will be minimal, so it should be kept as small as possible.\n\n## Base paths\n\nSince prpl-server serves resources from build subdirectories, your application source can't know the absolute URLs of build-specific resources upfront.\n\nFor most documents in your application, the solution is to use relative URLs to refer to other resources in the build, and absolute URLs to refer to resources outside of the build (e.g. static assets, APIs). However, since the *entrypoint* is served from URLs that do not match its location in the build tree, relative URLs will not resolve correctly.\n\nThe solution we recommend is to place a [`<base>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base) tag in your entrypoint to anchor its relative URLs to the correct build subdirectory, regardless of the URL the entrypoint was served from. You may then use relative URLs to refer to build-specific resources from your entrypoint, as though you were in your build subdirectory. Put `<base href=\"/\">` in your source entrypoint, so that URLs resolve when serving your source directly during development. In your build pipeline, update each entrypoint's base tag to match its build subdirectory (e.g. `<base href=\"/modern/\">`).\n\nIf you are using polymer-cli, set `{basePath: true}` on each build configuration to perform this base tag update automatically.\n\nNote that `<base>` tags only affect relative URLs, so to refer to resources outside of the build from your entrypoint, use absolute URLs as you normally would.\n\n## HTTP/2 Server Push\n\nServer Push allows an HTTP/2 server to preemptively send additional resources alongside a response. This can improve latency by eliminating subsequent round-trips for dependencies such as scripts, CSS, and HTML imports.\n\n\n### Push manifest\n\nprpl-server looks for a file called `push-manifest.json` in each build subdirectory, and uses it to map incoming request paths to the additional resources that should be pushed with it. The original push manifest file format is described [here](https://github.com/GoogleChrome/http2-push-manifest). Tools for generating a push manifest include [http2-push-manifest](https://github.com/GoogleChrome/http2-push-manifest) and [polymer-cli](https://github.com/Polymer/polymer-cli).\n\nEach key in the push manifest is a regular expression pattern that will be matched against the incoming request path. Patterns are forced to match exactly (e.g. `foo.html` is equivalent to `^foo.html$`). You can use wildcard patterns to push resources for client-side application routes (e.g. `/articles/.*`). In the case of the entrypoint, the resolved filename (e.g. `index.html`) is used as a key to the push manifest, in addition to the application route.\n\nResources in the push manifest can be specified as absolute or relative paths. Absolute paths are interpreted relative to the server root directory. Relative paths are interpreted relative to the location of the push manifest file itself (i.e. the build subdirectory), so that they do not need to know which build subdirectory they are being served from. Push manifests generated by `polymer-cli` always use relative paths.\n\n### Link preload headers\n\nprpl-server is designed to be used behind an HTTP/2 reverse proxy, and currently does not generate push responses itself. Instead it sets [preload link](https://w3c.github.io/preload/#server-push-http-2) headers, which are intercepted by cooperating reverse proxy servers and upgraded into push responses. Servers that implement this upgrading behavior include [Apache](https://httpd.apache.org/docs/trunk/mod/mod_http2.html#h2push), [nghttpx](https://github.com/nghttp2/nghttp2#nghttpx---proxy), and [Google App Engine](https://cloud.google.com/appengine/).\n\n### Testing push locally\n\nTo confirm your push manifest is working during local development, you can look for `Link: <URL>; rel=preload` response headers in your browser dev tools.\n\nTo see genuine push locally, you will need to run a local HTTP/2 reverse proxy such as [nghttpx](https://github.com/nghttp2/nghttp2#nghttpx---proxy):\n\n- Install nghttpx ([Homebrew](http://brewformulas.org/Nghttp2), [Ubuntu](http://packages.ubuntu.com/zesty/nghttp2), [source](https://github.com/nghttp2/nghttp2#building-from-git)).\n- Generate a self-signed TLS certificate, e.g. `openssl req -newkey rsa:2048 -x509 -nodes -keyout server.key -out server.crt`\n- Start prpl-server (assuming default `127.0.0.1:8080`).\n- Start nghttpx: `nghttpx -f127.0.0.1,8443 -b127.0.0.1,8080 server.key server.crt --no-ocsp`\n- Visit `https://localhost:8443`. In Chrome, Push responses will show up in the Network tab as Initiator: Push / Other.\n\nNote that Chrome will not allow a service worker to be registered over HTTPS with a self-signed certificate. You can enable [chrome://flags/#allow-insecure-localhost](chrome://flags/#allow-insecure-localhost) to bypass this check. See [this page](https://www.chromium.org/blink/serviceworker/service-worker-faq) for more tips on developing service workers in Chrome.\n\n## Service Workers\n\n### Scope header\nprpl-server sets the [`Service-Worker-Allowed`](https://www.w3.org/TR/service-workers-1/#service-worker-allowed) header to `/` for any request path ending with `service-worker.js`. This allows a service worker served from a build subdirectory to be registered with a scope outside of that directory, e.g. `register('service-worker.js', {scope: '/'})`.\n\n### 404 handling\n\nprpl-server automatically serves a tiny self-unregistering service worker for any request path ending with `service-worker.js` that would otherwise have had a `404 Not Found` response. To disable this behavior, set `unregisterMissingServiceWorkers: false` in your configuration file.\n\nThis can be useful when the location of a service worker has changed, as it will prevent clients from getting stuck with an old service worker indefinitely.\n\nThis problem arises because when a service worker updates, a `404` is treated as a failed update. It does not cause the service worker to be unregistered. See [w3c/ServiceWorker#204](https://github.com/w3c/ServiceWorker/issues/204) for more discussion of this problem.\n\n## HTTPS\n\nYour apps should always be served over HTTPS. It protects your user's data, and is *required* for features like service workers and HTTP/2.\n\nIf the `--https-redirect` flag is set, prpl-server will redirect all HTTP requests to HTTPS. It sends a `301 Moved Permanently` redirect to an `https://` address with the same hostname on the default HTTPS port (443).\n\nprpl-server trusts [`X-Forwarded-Proto`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto) and [`X-Forwarded-Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) headers from your reverse proxy to determine the client's true protocol and hostname. Most reverse proxies automatically set these headers, but if you encounter issues with redirect loops, missing or incorrect `X-Forwarded-*` headers may be the cause.\n\nYou should always use `--https-redirect` in production, unless your reverse proxy already performs HTTPS redirection.\n\n## Caching\n\nBy default, prpl-server sets the [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) header to `max-age=60` (1 minute), except for the entrypoint which gets `max-age=0`. [`ETag`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) headers are also sent, so resources that have not changed on the server can be re-validated efficiently.\n\nTo change this default for non-entrypoint resources, set the `cacheControl` property in your configuration file, or the `--cache-control` command-line flag, to the desired `Cache-Control` header value. You may want to set `--cache-control=no-cache` during development.\n\nFor more advanced caching behavior, [use prpl-server as a library](#as-a-library) with Express and register a middleware that sets the `Cache-Control` header before registering the prpl-server middleware. If prpl-server sees that the `Cache-Control` header has already been set, it will not modify it. For example, to set year-long caching for images:\n\n```js\napp.get('/images/*', (req, res, next) => {\n  res.setHeader('Cache-Control', 'public, max-age=31536000');\n  next();\n});\n\napp.get('/*', prpl.makeHandler('.', config))\n```\n\nChoosing the right cache headers for your application can be complex. See [*Caching best practices & max-age gotchas*](https://jakearchibald.com/2016/caching-best-practices/) for one starting point.\n\n## HTTP Errors\n\nBy default, if a `404 Not Found` or other HTTP server error occurs, prpl-server will serve a minimal `text/plain` response. To serve custom errors, [use prpl-server as a library](#as-a-library) with Express, set `forwardErrors: true` in your configuration object, and register an [error-handling middleware](http://expressjs.com/en/guide/error-handling.html) after registering the prpl-server handler:\n\n```js\napp.get('/*', prpl.makeHandler('.', {\n  builds: [ ... ],\n  forwardErrors: true\n}));\n\napp.use((err, req, res, next) => {\n  if (err.status === 404) {\n    res.status(404).sendFile('my-custom-404.html', {root: rootDir});\n  } else {\n    next();\n  }\n});\n```\n\n## Rendering for Bots\n\nMany bots don't execute JavaScript when processing your application. This can cause your application to not render correctly when crawled by some search engines, social networks, and link rendering bots.\n\nOne solution to this problem is [Rendertron](https://github.com/GoogleChrome/rendertron). Rendertron is a server which runs headless Chrome to render and serialize web pages for these bots, so all the content is contained in one network request. Use the `--bot-proxy` flag to instruct prpl-server to proxy requests from a known list of bots through a Rendertron server.\n\nNote that you can also use the [Rendertron middleware](https://github.com/GoogleChrome/rendertron/tree/master/middleware) directly if you have a custom Express server.\n\n## Google App Engine Quickstart\n\n[Google App Engine](https://cloud.google.com/appengine/) is a managed server platform that [supports Node](https://cloud.google.com/nodejs/) in its [Flexible Environment](https://cloud.google.com/appengine/docs/flexible/). You can deploy prpl-server to App Engine with a few steps:\n\n1. Follow [these instructions](https://cloud.google.com/appengine/docs/flexible/nodejs/quickstart) to set up a Google Cloud project and install the Google Cloud SDK. As instructed, run the `gcloud init` command to authenticate and choose your project ID.\n\n2. `cd` to the directory you want to serve (e.g. your app's `build/` directory if you are using polymer-cli).\n\n3. Run `npm init` and follow the prompts to create your `package.json`.\n\n4. Run `npm install --save prpl-server` to add prpl-server as a dependency.\n\n5. Edit your `package.json` to add a `start` script. This is the command App Engine runs when your app starts. Configure `prpl-server` to listen on all hosts, and to redirect HTTP connections to HTTPS. You should also specify the version of Node your app requires via the `engines` section.\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"prpl-server --host 0.0.0.0 --https-redirect\"\n  },\n  \"engines\": {\n    \"node\": \">=6.0.0\"\n  }\n}\n```\n\n6. Create an `app.yaml` file. This tells App Engine that you want to use the Node environment:\n\n```yaml\nruntime: nodejs\nenv: flex\n```\n\n7. Run `gcloud app deploy` to deploy to your App Engine project. `gcloud` will tell you the URL your app is being served from. For next steps, check out the Node on App Engine [documentation](https://cloud.google.com/nodejs/).\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Polymer/prpl-server-node.git"
  },
  "scripts": {
    "build": "rm -Rf lib/ && tsc",
    "build:watch": "tsc --watch",
    "format": "find src -name '*.ts' | xargs clang-format --style=file -i",
    "prepack": "npm run build",
    "prepublishOnly": "npm run test",
    "test": "npm run build && mocha",
    "test:watch": "watchy -w src -- npm run test"
  },
  "types": "lib/prpl.d.ts",
  "version": "1.0.0"
}
